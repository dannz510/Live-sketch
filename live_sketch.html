import React, { useRef, useEffect, useState, useCallback } from 'react';

// Main App component for the sketch application
function App() {
  // Refs for video, sketch canvas, and coloring canvas elements
  const videoRef = useRef(null);
  const sketchCanvasRef = useRef(null);
  const colorCanvasRef = useRef(null);

  // States for application features
  const [isDrawing, setIsDrawing] = useState(false);
  const [isCameraReady, setIsCameraReady] = useState(false);
  const [isColoringMode, setIsColoringMode] = useState(false);
  const [currentColor, setCurrentColor] = useState('#FF0000');
  const [message, setMessage] = useState('');
  const [isMirrored, setIsMirrored] = useState(true);
  const [activeTool, setActiveTool] = useState('draw'); // 'draw', 'fill', 'select'
  const [sketchStyle, setSketchStyle] = useState('classic');
  const [addedElements, setAddedElements] = useState([]); // Stores emojis and images
  const [drawingStrokes, setDrawingStrokes] = useState([]); // Stores freehand drawing data
  const [imageUrlInput, setImageUrlInput] = useState('');
  const [isImageLoading, setIsImageLoading] = useState(false);
  const [selectedElement, setSelectedElement] = useState(null); // The currently selected element for moving/resizing
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 }); // Offset for dragging
  const [isResizing, setIsResizing] = useState(false); // State for resizing
  const [resizeHandle, setResizeHandle] = useState(''); // 'nw', 'ne', 'sw', 'se'
  const [emojiPasteInput, setEmojiPasteInput] = useState(''); // For pasting custom emojis
  const [giphySearchTerm, setGiphySearchTerm] = useState(''); // For Giphy search
  const [giphyResults, setGiphyResults] = useState([]); // Giphy search results
  const [isGiphySearching, setIsGiphySearching] = useState(false); // Giphy loading indicator

  // Giphy API Key: IMPORTANT! Replace this with your actual Giphy API Key.
  // You can get one from https://developers.giphy.com/
  const GIPHY_API_KEY = 'Vpgm2IcVFYvOFj5Q68SNL1uIJcBZ2pMC'; // Updated with your provided API key

  // List of common emojis to choose from
  const emojiOptions = ['ðŸ˜€', 'ðŸ˜‚', 'ðŸ˜', 'ðŸ‘', 'ðŸŽ‰', 'ï¿½', 'ðŸŒˆ', 'ðŸ’¡', 'ðŸŒŸ', 'â¤ï¸', 'ðŸ”¥', 'âœ¨'];

  // Function to display a temporary message
  const showMessage = (msg, duration = 3000) => {
    setMessage(msg);
    setTimeout(() => setMessage(''), duration);
  };

  // Effect to initialize the camera and start the video stream
  useEffect(() => {
    const setupCamera = async () => {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        if (videoRef.current) {
          videoRef.current.srcObject = stream;
          videoRef.current.play();
          setIsCameraReady(true);
        }
      } catch (err) {
        console.error("Error accessing camera: ", err);
        showMessage("Failed to access camera. Please ensure it's connected and permissions are granted.");
      }
    };

    setupCamera();

    return () => {
      if (videoRef.current && videoRef.current.srcObject) {
        const tracks = videoRef.current.srcObject.getTracks();
        tracks.forEach(track => track.stop());
      }
    };
  }, []);

  // Helper function to get pixel index
  const getPixelIndex = (x, y, width) => (y * width + x) * 4;

  // Filter: Grayscale
  const applyGrayscale = useCallback((imageData) => {
    const data = imageData.data;
    for (let i = 0; i < data.length; i += 4) {
      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
      data[i] = avg;
      data[i + 1] = avg;
      data[i + 2] = avg;
    }
    return imageData;
  }, []);

  // Filter: Basic Edge Detection (Sobel approximation)
  const applyEdgeDetection = useCallback((imageData, width, height, invert = false) => {
    const data = imageData.data;
    const newData = new Uint8ClampedArray(data.length);

    const sobelX = [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]];
    const sobelY = [[-1, -2, -1], [0, 0, 0], [1, 2, 1]];

    for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
        let gx = 0;
        let gy = 0;

        for (let ky = -1; ky <= 1; ky++) {
          for (let kx = -1; kx <= 1; kx++) {
            const pixelIndex = getPixelIndex(x + kx, y + ky, width);
            const grayValue = data[pixelIndex];

            gx += grayValue * sobelX[ky + 1][kx + 1];
            gy += grayValue * sobelY[ky + 1][kx + 1];
          }
        }

        const magnitude = Math.sqrt(gx * gx + gy * gy);
        let outputValue = magnitude > 50 ? 0 : 255;

        if (invert) {
          outputValue = 255 - outputValue;
        }

        const outputIndex = getPixelIndex(x, y, width);
        newData[outputIndex] = outputValue;
        newData[outputIndex + 1] = outputValue;
        newData[outputIndex + 2] = outputValue;
        newData[outputIndex + 3] = 255;
      }
    }
    for (let i = 0; i < data.length; i++) {
      data[i] = newData[i];
    }
    return imageData;
  }, []);

  // Filter: Pencil Sketch (Grayscale + subtle edge blend)
  const applyPencilSketch = useCallback((imageData, width, height) => {
    let processedData = applyGrayscale({ ...imageData });
    const data = processedData.data;

    const blurRadius = 1;
    const blurredData = new Uint8ClampedArray(data.length);
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let rSum = 0, gSum = 0, bSum = 0, count = 0;
        for (let dy = -blurRadius; dy <= blurRadius; dy++) {
          for (let dx = -blurRadius; dx <= blurRadius; dx++) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
              const idx = getPixelIndex(nx, ny, width);
              rSum += data[idx];
              gSum += data[idx + 1];
              bSum += data[idx + 2];
              count++;
            }
          }
        }
        const currentIdx = getPixelIndex(x, y, width);
        blurredData[currentIdx] = rSum / count;
        blurredData[currentIdx + 1] = gSum / count;
        blurredData[currentIdx + 2] = bSum / count;
        blurredData[currentIdx + 3] = 255;
      }
    }

    const edgeData = applyEdgeDetection({ ...imageData }, width, height, true);

    for (let i = 0; i < data.length; i += 4) {
      const blendedRed = (blurredData[i] * 0.7) + (edgeData.data[i] * 0.3);
      const blendedGreen = (blurredData[i + 1] * 0.7) + (edgeData.data[i + 1] * 0.3);
      const blendedBlue = (blurredData[i + 2] * 0.7) + (edgeData.data[i + 2] * 0.3);

      data[i] = Math.min(255, Math.max(0, blendedRed));
      data[i + 1] = Math.min(255, Math.max(0, blendedGreen));
      data[i + 2] = Math.min(255, Math.max(0, blendedBlue));
    }
    return imageData;
  }, [applyGrayscale, applyEdgeDetection]);

  // Filter: Cartoon/Posterize Effect
  const applyCartoonEffect = useCallback((imageData) => {
    const data = imageData.data;
    const levels = 4;
    const interval = 255 / (levels - 1);

    for (let i = 0; i < data.length; i += 4) {
      data[i] = Math.floor(data[i] / interval) * interval;
      data[i + 1] = Math.floor(data[i + 1] / interval) * interval;
      data[i + 2] = Math.floor(data[i + 2] / interval) * interval;
    }
    return imageData;
  }, []);

  // Filter: Sepia Tone
  const applySepiaTone = useCallback((imageData) => {
    const data = imageData.data;
    for (let i = 0; i < data.length; i += 4) {
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];

      data[i] = Math.min(255, (r * 0.393) + (g * 0.769) + (b * 0.189));
      data[i + 1] = Math.min(255, (r * 0.349) + (g * 0.686) + (b * 0.168));
      data[i + 2] = Math.min(255, (r * 0.272) + (g * 0.534) + (b * 0.131));
    }
    return imageData;
  }, []);

  // Filter: High Contrast (Threshold)
  const applyThreshold = useCallback((imageData) => {
    let processedData = applyGrayscale({ ...imageData });
    const data = processedData.data;
    const threshold = 128;

    for (let i = 0; i < data.length; i += 4) {
      const avg = data[i];
      const value = avg > threshold ? 255 : 0;
      data[i] = value;
      data[i + 1] = value;
      data[i + 2] = value;
    }
    return imageData;
  }, [applyGrayscale]);

  // Effect to continuously draw video frames to canvas and apply sketch effect
  useEffect(() => {
    const video = videoRef.current;
    const sketchCanvas = sketchCanvasRef.current;
    if (!video || !sketchCanvas || !isCameraReady) return;

    const context = sketchCanvas.getContext('2d', { willReadFrequently: true });

    const drawSketch = () => {
      if (video.paused || video.ended) {
        requestAnimationFrame(drawSketch);
        return;
      }

      sketchCanvas.width = video.videoWidth;
      sketchCanvas.height = video.videoHeight;

      if (sketchCanvas.width === 0 || sketchCanvas.height === 0) {
        requestAnimationFrame(drawSketch);
        return;
      }

      context.clearRect(0, 0, sketchCanvas.width, sketchCanvas.height);

      context.save();
      if (isMirrored) {
        context.scale(-1, 1);
        context.drawImage(video, -sketchCanvas.width, 0, sketchCanvas.width, sketchCanvas.height);
      } else {
        context.drawImage(video, 0, 0, sketchCanvas.width, sketchCanvas.height);
      }
      context.restore();

      let imageData = context.getImageData(0, 0, sketchCanvas.width, sketchCanvas.height);

      switch (sketchStyle) {
        case 'classic':
          imageData = applyGrayscale(imageData);
          imageData = applyEdgeDetection(imageData, sketchCanvas.width, sketchCanvas.height, false);
          break;
        case 'inverted':
          imageData = applyGrayscale(imageData);
          imageData = applyEdgeDetection(imageData, sketchCanvas.width, sketchCanvas.height, true);
          break;
        case 'pencil':
          imageData = applyPencilSketch(imageData, sketchCanvas.width, sketchCanvas.height);
          break;
        case 'cartoon':
          imageData = applyCartoonEffect(imageData);
          break;
        case 'sepia':
          imageData = applySepiaTone(imageData);
          break;
        case 'threshold':
          imageData = applyThreshold(imageData);
          break;
        default:
          break;
      }

      context.putImageData(imageData, 0, 0);
      requestAnimationFrame(drawSketch);
    };

    video.addEventListener('loadeddata', drawSketch);
    requestAnimationFrame(drawSketch);

    return () => {
      video.removeEventListener('loadeddata', drawSketch);
    };
  }, [isCameraReady, isMirrored, sketchStyle, applyGrayscale, applyEdgeDetection, applyPencilSketch, applyCartoonEffect, applySepiaTone, applyThreshold]);

  // Function to capture the sketch canvas and save as PNG
  const captureAndSave = () => {
    const sketchCanvas = sketchCanvasRef.current;
    const colorCanvas = colorCanvasRef.current;

    if (!sketchCanvas) {
      showMessage("No sketch to capture!");
      return;
    }

    const mergedCanvas = document.createElement('canvas');
    mergedCanvas.width = sketchCanvas.width;
    mergedCanvas.height = sketchCanvas.height;
    const mergedContext = mergedCanvas.getContext('2d');

    mergedContext.drawImage(sketchCanvas, 0, 0);

    if (isColoringMode && colorCanvas) {
      mergedContext.drawImage(colorCanvas, 0, 0);
    }

    const image = mergedCanvas.toDataURL('image/png');

    const link = document.createElement('a');
    link.href = image;
    link.download = `sketch-${new Date().toISOString().slice(0, 19).replace(/[:.-]/g, '')}.png`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    showMessage("Sketch captured and saved!");
  };

  // Helper function to convert hex color to RGBA
  const hexToRgba = (hex) => {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return [r, g, b, 255];
  };

  // Flood Fill Algorithm
  const floodFill = useCallback((startX, startY) => {
    const sketchCanvas = sketchCanvasRef.current;
    const colorCanvas = colorCanvasRef.current;
    if (!sketchCanvas || !colorCanvas) return;

    const sketchCtx = sketchCanvas.getContext('2d');
    const colorCtx = colorCanvas.getContext('2d');

    const sketchImageData = sketchCtx.getImageData(0, 0, sketchCanvas.width, sketchCanvas.height);
    const sketchPixels = sketchImageData.data;

    const colorImageData = colorCtx.getImageData(0, 0, colorCanvas.width, colorCanvas.height);
    const colorPixels = colorImageData.data;

    const width = sketchCanvas.width;
    const height = colorCanvas.height;

    const getPixelColor = (pixels, x, y) => {
      const index = getPixelIndex(x, y, width);
      return [pixels[index], pixels[index + 1], pixels[index + 2], pixels[index + 3]];
    };

    const setPixelColor = (pixels, x, y, color) => {
      const index = getPixelIndex(x, y, width);
      pixels[index] = color[0];
      pixels[index + 1] = color[1];
      pixels[index + 2] = color[2];
      pixels[index + 3] = color[3];
    };

    const fillColor = hexToRgba(currentColor);
    const isBoundary = (r, g, b) => r < 50 && g < 50 && b < 50;

    const startPixelColorOnColorCanvas = getPixelColor(colorPixels, startX, startY);
    const startPixelColorOnSketchCanvas = getPixelColor(sketchPixels, startX, startY);

    if (
        (startPixelColorOnColorCanvas[0] === fillColor[0] &&
         startPixelColorOnColorCanvas[1] === fillColor[1] &&
         startPixelColorOnColorCanvas[2] === fillColor[2] &&
         startPixelColorOnColorCanvas[3] === fillColor[3]) ||
        isBoundary(startPixelColorOnSketchCanvas[0], startPixelColorOnSketchCanvas[1], startPixelColorOnSketchCanvas[2])
    ) {
        return;
    }

    const queue = [[startX, startY]];
    const visited = new Set();

    const getPixelKey = (x, y) => `${x},${y}`;

    while (queue.length > 0) {
      const [x, y] = queue.shift();
      const key = getPixelKey(x, y);

      if (visited.has(key)) continue;
      visited.add(key);

      if (x >= 0 && x < width && y >= 0 && y < height) {
        const currentSketchPixelColor = getPixelColor(sketchPixels, x, y);
        const currentColorPixelColor = getPixelColor(colorPixels, x, y);

        if (!isBoundary(currentSketchPixelColor[0], currentSketchPixelColor[1], currentSketchPixelColor[2]) &&
            (currentColorPixelColor[0] !== fillColor[0] ||
             currentColorPixelColor[1] !== fillColor[1] ||
             currentColorPixelColor[2] !== fillColor[2] ||
             currentColorPixelColor[3] !== fillColor[3])) {
          setPixelColor(colorPixels, x, y, fillColor);

          queue.push([x + 1, y]);
          queue.push([x - 1, y]);
          queue.push([x, y + 1]);
          queue.push([x, y - 1]);
        }
      }
    }
    colorCtx.putImageData(colorImageData, 0, 0);
  }, [currentColor]);

  // Function to add an emoji to the canvas (now at click position)
  const addEmojiToCanvas = useCallback((emoji, x, y) => {
    const colorCanvas = colorCanvasRef.current;
    if (!colorCanvas) return;

    const size = 40; // Default size for new emojis
    setAddedElements(prevElements => [
      ...prevElements,
      { id: Date.now(), type: 'emoji', value: emoji, x, y, width: size, height: size } // Added width and height
    ]);
    showMessage(`Added ${emoji} to sketch!`);
  }, []);

  // Function to add an image from a URL to the canvas (now at click position)
  const addImageFromUrl = useCallback(async (url, x, y) => {
    if (!url) {
      showMessage("Please enter an image URL.");
      return;
    }

    setIsImageLoading(true);
    showMessage("Loading image...");

    try {
      const img = new Image();
      img.crossOrigin = "Anonymous";
      img.src = url;

      img.onload = () => {
        const colorCanvas = colorCanvasRef.current;
        if (!colorCanvas) return;

        let drawWidth = img.width;
        let drawHeight = img.height;
        const maxWidth = 100;
        const maxHeight = 100;

        if (drawWidth > maxWidth || drawHeight > maxHeight) {
          const aspectRatio = drawWidth / drawHeight;
          if (drawWidth > drawHeight) {
            drawWidth = maxWidth;
            drawHeight = maxWidth / aspectRatio;
          } else {
            drawHeight = maxHeight;
            drawWidth = maxHeight * aspectRatio;
          }
        }

        setAddedElements(prevElements => [
          ...prevElements,
          { id: Date.now(), type: 'image', value: img, x, y, width: drawWidth, height: drawHeight }
        ]);
        setImageUrlInput('');
        showMessage("Image added successfully!");
        setIsImageLoading(false);
      };

      img.onerror = () => {
        showMessage("Failed to load image. Please check the URL and ensure it allows cross-origin access.");
        setIsImageLoading(false);
      };
    } catch (error) {
      console.error("Error adding image:", error);
      showMessage("An error occurred while adding the image.");
      setIsImageLoading(false);
    }
  }, []);

  // Giphy Search Function
  const searchGiphy = useCallback(async () => {
    if (!GIPHY_API_KEY) {
      showMessage("Giphy API Key is missing. Please add it to the code for this feature to work.");
      return;
    }
    const term = giphySearchTerm.trim();
    if (!term) {
      showMessage("Please enter a search term for Giphy.");
      return;
    }

    setIsGiphySearching(true);
    setGiphyResults([]);
    showMessage("Searching Giphy...");

    try {
      const response = await fetch(`https://api.giphy.com/v1/gifs/search?api_key=${GIPHY_API_KEY}&q=${encodeURIComponent(term)}&limit=9`);
      const data = await response.json();

      if (data.data && data.data.length > 0) {
        setGiphyResults(data.data.map(gif => ({
          id: gif.id,
          url: gif.images.fixed_width_downsampled.url, // Use fixed_width_downsampled for preview
          original_url: gif.images.original.url // Use original for embedding
        })));
        showMessage(`Found ${data.data.length} Giphy results.`);
      } else {
        setGiphyResults([]);
        showMessage("No Giphy results found for your search.");
      }
    } catch (error) {
      console.error("Error searching Giphy:", error);
      showMessage("Failed to search Giphy. Please try again later.");
    } finally {
      setIsGiphySearching(false);
    }
  }, [giphySearchTerm, GIPHY_API_KEY]);

  // Handle adding Giphy image to canvas
  const handleAddGiphy = useCallback((giphyItem) => {
    const colorCanvas = colorCanvasRef.current;
    if (!colorCanvas) return;

    // Place Giphy image at the center of the canvas initially
    const x = colorCanvas.width / 2 - 50;
    const y = colorCanvas.height / 2 - 50;

    addImageFromUrl(giphyItem.original_url, x, y);
  }, [addImageFromUrl]);

  // Function to delete the currently selected element
  const deleteSelectedElement = useCallback(() => {
    if (selectedElement) {
      setAddedElements(prevElements => prevElements.filter(el => el.id !== selectedElement.id));
      setSelectedElement(null);
      showMessage("Element deleted!");
    } else {
      showMessage("No element selected to delete.");
    }
  }, [selectedElement]);

  // Function to undo the last drawing stroke
  const undoLastStroke = useCallback(() => {
    if (drawingStrokes.length > 0) {
      setDrawingStrokes(prevStrokes => prevStrokes.slice(0, prevStrokes.length - 1));
      showMessage("Last stroke undone!");
    } else {
      showMessage("No strokes to undo.");
    }
  }, [drawingStrokes.length]);


  // Event handlers for drawing and element interaction
  const handleMouseDown = useCallback((e) => {
    const colorCanvas = colorCanvasRef.current;
    if (!colorCanvas || !isColoringMode) return;

    // Prevent default browser behavior (like scrolling on touch)
    e.preventDefault();

    const rect = colorCanvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    const x = clientX - rect.left;
    const y = clientY - rect.top;

    if (activeTool === 'draw') {
      setDrawingStrokes(prevStrokes => [
        ...prevStrokes,
        { color: currentColor, lineWidth: 5, points: [{ x, y }] }
      ]);
      setIsDrawing(true);
    } else if (activeTool === 'fill') {
      floodFill(x, y);
    } else if (activeTool === 'select') {
      let clickedElement = null;
      let isHandleClicked = false;
      let newResizeHandle = '';

      // Check for resize handles of the *currently selected* element first
      if (selectedElement) {
        const { x: elX, y: elY, width: elW, height: elH } = selectedElement;
        const handleSize = 10;

        // Helper to check if point is within a handle
        const isPointInHandle = (px, py, hx, hy) =>
          px >= hx - handleSize / 2 && px <= hx + handleSize / 2 &&
          py >= hy - handleSize / 2 && py <= hy + handleSize / 2;

        // Top-left
        if (isPointInHandle(x, y, elX, elY)) { isHandleClicked = true; newResizeHandle = 'nw'; }
        // Top-right
        else if (isPointInHandle(x, y, elX + elW, elY)) { isHandleClicked = true; newResizeHandle = 'ne'; }
        // Bottom-left
        else if (isPointInHandle(x, y, elX, elY + elH)) { isHandleClicked = true; newResizeHandle = 'sw'; }
        // Bottom-right
        else if (isPointInHandle(x, y, elX + elW, elY + elH)) { isHandleClicked = true; newResizeHandle = 'se'; }

        if (isHandleClicked) {
          setIsResizing(true);
          setResizeHandle(newResizeHandle);
          // Drag offset for resizing is from the handle's center to the mouse click
          setDragOffset({ x: x - elX, y: y - elY }); // This will be used to correctly adjust newX/newY for 'nw'/'sw' handles

          // Capture initial state for resizing
          clickedElement = {
            ...selectedElement,
            initialX: elX,
            initialY: elY,
            initialWidth: elW,
            initialHeight: elH
          };
        }
      }

      // If no handle was clicked OR there was no previously selected element, try to select a new element for dragging
      if (!isHandleClicked) {
        for (let i = addedElements.length - 1; i >= 0; i--) { // Iterate backwards to select top-most
          const element = addedElements[i];
          // Check if click is within the element's bounding box
          if (x >= element.x && x <= element.x + element.width && y >= element.y && y <= element.y + element.height) {
            clickedElement = {
              ...element,
              // Store current x,y,width,height as initial for future resizing
              initialX: element.x,
              initialY: element.y,
              initialWidth: element.width,
              initialHeight: element.height
            };
            setDragOffset({ x: x - element.x, y: y - element.y }); // Offset for dragging the whole element
            setIsResizing(false); // Ensure resizing is off for dragging
            setResizeHandle('');
            break;
          }
        }
      }

      // Update selectedElement state
      setSelectedElement(clickedElement);
      if (!clickedElement) {
        setIsResizing(false); // If nothing clicked, ensure resizing is false
        setResizeHandle('');
      }
    }
  }, [activeTool, isColoringMode, currentColor, floodFill, addedElements, selectedElement, setIsDrawing, setIsResizing, setResizeHandle, setDragOffset]);

  const handleMouseMove = useCallback((e) => {
    const colorCanvas = colorCanvasRef.current;
    if (!colorCanvas || !isColoringMode) return;

    const rect = colorCanvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    const currentMouseX = clientX - rect.left;
    const currentMouseY = clientY - rect.top;

    if (activeTool === 'draw' && isDrawing && drawingStrokes.length > 0) {
      const lastStrokeIndex = drawingStrokes.length - 1;
      setDrawingStrokes(prevStrokes => {
        const newStrokes = [...prevStrokes];
        newStrokes[lastStrokeIndex].points.push({ x: currentMouseX, y: currentMouseY });
        return newStrokes;
      });
    } else if (activeTool === 'select' && selectedElement) {
      // Retrieve initial state from selectedElement
      const initialX = selectedElement.initialX;
      const initialY = selectedElement.initialY;
      const initialWidth = selectedElement.initialWidth;
      const initialHeight = selectedElement.initialHeight;

      if (isResizing) {
        setAddedElements(prevElements => prevElements.map(el => {
          if (el.id === selectedElement.id) {
            let newX = initialX;
            let newY = initialY;
            let newWidth = initialWidth;
            let newHeight = initialHeight;

            // Calculate new dimensions based on resize handle
            if (resizeHandle.includes('e')) {
                newWidth = currentMouseX - initialX;
            }
            if (resizeHandle.includes('s')) {
                newHeight = currentMouseY - initialY;
            }
            if (resizeHandle.includes('w')) {
                newX = currentMouseX - dragOffset.x; // Use dragOffset to keep mouse on handle
                newWidth = initialX + initialWidth - newX;
            }
            if (resizeHandle.includes('n')) {
                newY = currentMouseY - dragOffset.y; // Use dragOffset to keep mouse on handle
                newHeight = initialY + initialHeight - newY;
            }

            // Adjust for aspect ratio for images/emojis
            const aspectRatio = el.type === 'image' && el.value.naturalWidth && el.value.naturalHeight
              ? el.value.naturalWidth / el.value.naturalHeight
              : 1; // Emojis are treated as square for aspect ratio

            if (resizeHandle.length === 2) { // Diagonal resize
              // Prioritize the dimension that changed more
              if (Math.abs(newWidth - initialWidth) > Math.abs(newHeight - initialHeight)) {
                newHeight = newWidth / aspectRatio;
              } else {
                newWidth = newHeight * aspectRatio;
              }
            } else if (resizeHandle.includes('e') || resizeHandle.includes('w')) {
              newHeight = newWidth / aspectRatio;
            } else if (resizeHandle.includes('s') || resizeHandle.includes('n')) {
              newWidth = newHeight * aspectRatio;
            }

            // Ensure minimum size
            newWidth = Math.max(10, newWidth);
            newHeight = Math.max(10, newHeight);

            return {
              ...el,
              x: newX,
              y: newY,
              width: newWidth,
              height: newHeight,
            };
          }
          return el;
        }));
      } else { // Dragging
        setAddedElements(prevElements => prevElements.map(el => {
          if (el.id === selectedElement.id) {
            let newX = currentMouseX - dragOffset.x;
            let newY = currentMouseY - dragOffset.y;

            // Keep within canvas bounds
            newX = Math.max(0, Math.min(newX, colorCanvas.width - el.width));
            newY = Math.max(0, Math.min(newY, colorCanvas.height - el.height));

            return { ...el, x: newX, y: newY };
          }
          return el;
        }));
      }
    }
  }, [activeTool, isColoringMode, isDrawing, drawingStrokes, selectedElement, dragOffset, isResizing, resizeHandle]);

  const handleMouseUp = useCallback(() => {
    setIsDrawing(false); // Stop drawing
    setIsResizing(false); // Stop resizing
    setResizeHandle(''); // Clear resize handle
  }, [setIsDrawing, setIsResizing, setResizeHandle]);

  const handleMouseOut = useCallback(() => {
    // If drawing, stop drawing when mouse leaves canvas
    if (activeTool === 'draw' && isDrawing) {
      setIsDrawing(false);
    }
    setIsResizing(false);
    setResizeHandle('');
  }, [activeTool, isDrawing, setIsDrawing, setIsResizing, setResizeHandle]);


  // Effect to set up coloring canvas when coloring mode is active
  useEffect(() => {
    const colorCanvas = colorCanvasRef.current;
    const sketchCanvas = sketchCanvasRef.current;
    if (!colorCanvas || !sketchCanvas) return;

    const ctx = colorCanvas.getContext('2d');

    colorCanvas.width = sketchCanvas.width;
    colorCanvas.height = sketchCanvas.height;

    const redrawColoringCanvas = () => {
      ctx.clearRect(0, 0, colorCanvas.width, colorCanvas.height);

      // Redraw all drawing strokes
      drawingStrokes.forEach(stroke => {
        ctx.strokeStyle = stroke.color;
        ctx.lineWidth = stroke.lineWidth;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        if (stroke.points.length > 0) {
          ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
          for (let i = 1; i < stroke.points.length; i++) {
            ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
          }
        }
        ctx.stroke();
      });

      // Redraw all added elements
      addedElements.forEach(element => {
        if (element.type === 'emoji') {
          // For emojis, x,y is top-left, but fillText uses baseline. Adjust y.
          ctx.font = `${element.width}px Arial`; // Use width as size for emoji
          ctx.fillText(element.value, element.x, element.y + element.height);
        } else if (element.type === 'image' && element.value.complete) {
          ctx.drawImage(element.value, element.x, element.y, element.width, element.height);
        }
      });

      // Draw selection border and handles for selected element
      if (selectedElement) {
        const { x, y, width, height } = selectedElement;

        ctx.strokeStyle = '#00BFFF'; // Cyan border
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]); // Dashed line
        ctx.strokeRect(x, y, width, height);
        ctx.setLineDash([]); // Reset line dash

        // Draw resize handles
        const handleSize = 10;
        ctx.fillStyle = '#00BFFF';
        ctx.strokeStyle = '#FFFFFF';
        ctx.lineWidth = 1;

        // Top-left
        ctx.fillRect(x - handleSize / 2, y - handleSize / 2, handleSize, handleSize);
        ctx.strokeRect(x - handleSize / 2, y - handleSize / 2, handleSize, handleSize);
        // Top-right
        ctx.fillRect(x + width - handleSize / 2, y - handleSize / 2, handleSize, handleSize);
        ctx.strokeRect(x + width - handleSize / 2, y - handleSize / 2, handleSize, handleSize);
        // Bottom-left
        ctx.fillRect(x - handleSize / 2, y + height - handleSize / 2, handleSize, handleSize);
        ctx.strokeRect(x - handleSize / 2, y + height - handleSize / 2, handleSize, handleSize);
        // Bottom-right
        ctx.fillRect(x + width - handleSize / 2, y + height - handleSize / 2, handleSize, handleSize);
        ctx.strokeRect(x + width - handleSize / 2, y + height - handleSize / 2, handleSize, handleSize);
      }
    };

    redrawColoringCanvas(); // Initial draw and on state changes

    // Attach event listeners to the canvas
    colorCanvas.addEventListener('mousedown', handleMouseDown);
    colorCanvas.addEventListener('mousemove', handleMouseMove);
    colorCanvas.addEventListener('mouseup', handleMouseUp);
    colorCanvas.addEventListener('mouseout', handleMouseOut); // To stop drawing if mouse leaves

    colorCanvas.addEventListener('touchstart', handleMouseDown);
    colorCanvas.addEventListener('touchmove', handleMouseMove);
    colorCanvas.addEventListener('touchend', handleMouseUp);
    colorCanvas.addEventListener('touchcancel', handleMouseOut);


    // Cleanup: remove event listeners
    return () => {
      colorCanvas.removeEventListener('mousedown', handleMouseDown);
      colorCanvas.removeEventListener('mousemove', handleMouseMove);
      colorCanvas.removeEventListener('mouseup', handleMouseUp);
      colorCanvas.removeEventListener('mouseout', handleMouseOut);
      colorCanvas.removeEventListener('touchstart', handleMouseDown);
      colorCanvas.removeEventListener('touchmove', handleMouseMove);
      colorCanvas.removeEventListener('touchend', handleMouseUp);
      colorCanvas.removeEventListener('touchcancel', handleMouseOut);
    };
  }, [isColoringMode, currentColor, activeTool, drawingStrokes, addedElements, selectedElement, handleMouseDown, handleMouseMove, handleMouseUp, handleMouseOut]);

  // Function to clear the coloring canvas and added elements
  const clearAll = () => {
    const colorCanvas = colorCanvasRef.current;
    if (colorCanvas) {
      const ctx = colorCanvas.getContext('2d');
      ctx.clearRect(0, 0, colorCanvas.width, colorCanvas.height);
      setAddedElements([]); // Clear all added emojis/elements
      setDrawingStrokes([]); // Clear all drawing strokes
      setSelectedElement(null); // Deselect any element
      showMessage("Canvas cleared!");
    }
  };

  // Handle pasting emoji from input field
  const handlePasteEmoji = useCallback(() => {
    const emoji = emojiPasteInput.trim();
    if (emoji) {
      const colorCanvas = colorCanvasRef.current;
      if (colorCanvas) {
        // Place pasted emoji at center initially
        const x = colorCanvas.width / 2 - 20;
        const y = colorCanvas.height / 2 - 20;
        addEmojiToCanvas(emoji, x, y);
        setEmojiPasteInput('');
      }
    } else {
      showMessage("Please paste an emoji into the box.");
    }
  }, [emojiPasteInput, addEmojiToCanvas]);


  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 to-gray-700 text-white font-inter flex flex-col items-center justify-center p-4">
      <h1 className="text-4xl md:text-5xl font-extrabold mb-8 text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-600 drop-shadow-lg">
        Live Sketcher
      </h1>

      <div className="relative w-full max-w-3xl aspect-video bg-gray-800 rounded-xl shadow-2xl overflow-hidden mb-8">
        {/* Hidden video element to capture camera stream */}
        <video key="video-stream" ref={videoRef} className="absolute inset-0 w-full h-full object-cover" autoPlay playsInline muted></video>
        {/* Canvas to display the live sketch effect */}
        <canvas ref={sketchCanvasRef} className="absolute inset-0 w-full h-full object-cover"></canvas>
        {/* Canvas for coloring, overlaid on top of the sketch */}
        {isColoringMode && (
          <canvas
            key="coloringCanvas" // Added key for conditional rendering
            ref={colorCanvasRef}
            className={`absolute inset-0 w-full h-full object-cover z-10 ${
              activeTool === 'draw' ? 'cursor-crosshair' :
              activeTool === 'fill' ? 'cursor-pointer' :
              activeTool === 'select' ? (selectedElement ? (isResizing ? 'cursor-nesw-resize' : 'cursor-move') : 'cursor-default') :
              'cursor-default'
            }`}
            style={{ touchAction: 'none' }}
          ></canvas>
        )}
        {!isCameraReady && (
          <div className="absolute inset-0 flex items-center justify-center bg-gray-900 bg-opacity-70 text-gray-300 text-lg">
            Loading camera... Please allow camera access.
          </div>
        )}
      </div>

      {message && (
        <div className="absolute top-4 bg-blue-500 text-white px-4 py-2 rounded-lg shadow-md animate-fade-in-out z-20">
          {message}
        </div>
      )}

      <div className="flex flex-wrap justify-center gap-4 mb-8">
        {/* Capture Button */}
        <button
          onClick={captureAndSave}
          className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transform transition duration-300 ease-in-out hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-500 focus:ring-opacity-50 flex items-center space-x-2"
        >
          <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
            <path strokeLinecap="round" strokeLinejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
          </svg>
          <span>Capture & Save</span>
        </button>

        {/* Toggle Coloring Mode Button */}
        <button
          onClick={() => setIsColoringMode(!isColoringMode)}
          className={`font-bold py-3 px-6 rounded-lg shadow-lg transform transition duration-300 ease-in-out hover:scale-105 focus:outline-none focus:ring-4 ${
            isColoringMode
              ? 'bg-red-600 hover:bg-red-700 focus:ring-red-500 text-white'
              : 'bg-green-600 hover:bg-green-700 focus:ring-green-500 text-white'
          } focus:ring-opacity-50 flex items-center space-x-2`}
        >
          <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
            <path strokeLinecap="round" strokeLinejoin="round" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343h7.071c.792 0 1.5.385 1.948 1.04A3 3 0 0122 10.87V16m-2 0h2.071M12 7.343h7.071M15 19v-4m-2 2h4" />
          </svg>
          <span>{isColoringMode ? 'Exit Coloring' : 'Start Coloring'}</span>
        </button>

        {/* Toggle Mirror Mode Button */}
        <button
          onClick={() => setIsMirrored(!isMirrored)}
          className={`font-bold py-3 px-6 rounded-lg shadow-lg transform transition duration-300 ease-in-out hover:scale-105 focus:outline-none focus:ring-4 ${
            isMirrored
              ? 'bg-purple-600 hover:bg-purple-700 focus:ring-purple-500 text-white'
              : 'bg-indigo-600 hover:bg-indigo-700 focus:ring-indigo-500 text-white'
          } focus:ring-opacity-50 flex items-center space-x-2`}
        >
          <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
            <path strokeLinecap="round" strokeLinejoin="round" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
          </svg>
          <span>{isMirrored ? 'Disable Mirror' : 'Enable Mirror'}</span>
        </button>
      </div>

      {/* Sketch Style Selector */}
      <div className="flex items-center space-x-4 mb-8">
        <label htmlFor="sketchStyle" className="text-lg font-semibold">Sketch Style:</label>
        <select
          id="sketchStyle"
          value={sketchStyle}
          onChange={(e) => setSketchStyle(e.target.value)}
          className="bg-gray-700 text-white py-2 px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-blue-500"
        >
          <option value="classic">Classic Sketch</option>
          <option value="inverted">Inverted Sketch</option>
          <option value="pencil">Pencil Sketch</option>
          <option value="cartoon">Cartoon/Posterize</option>
          <option value="sepia">Sepia Tone</option>
          <option value="threshold">High Contrast</option>
        </select>
      </div>

      {/* Coloring Tools (only visible in coloring mode) */}
      {isColoringMode && (
        <div className="flex flex-col md:flex-row items-center gap-4 mb-8 p-4 bg-gray-800 rounded-lg shadow-inner w-full max-w-4xl">
          {/* Color Picker */}
          <div className="flex items-center space-x-4">
            <label htmlFor="colorPicker" className="text-lg font-semibold">Color:</label>
            <input
              type="color"
              id="colorPicker"
              value={currentColor}
              onChange={(e) => setCurrentColor(e.target.value)}
              className="w-16 h-10 rounded-md border-2 border-gray-600 cursor-pointer"
              title="Select drawing color"
            />
          </div>

          {/* Tool Selection */}
          <div className="flex items-center space-x-4 mt-4 md:mt-0">
            <span className="text-lg font-semibold">Tool:</span>
            <button
              onClick={() => setActiveTool('draw')}
              className={`py-2 px-4 rounded-lg font-semibold transition duration-200 ${
                activeTool === 'draw' ? 'bg-blue-500 text-white shadow-md' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
              }`}
              title="Freehand Drawing Tool"
            >
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 inline-block mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
                <path strokeLinecap="round" strokeLinejoin="round" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
              </svg>
              Draw
            </button>
            <button
              onClick={() => setActiveTool('fill')}
              className={`py-2 px-4 rounded-lg font-semibold transition duration-200 ${
                activeTool === 'fill' ? 'bg-blue-500 text-white shadow-md' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
              }`}
              title="Fill (Bucket) Tool"
            >
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 inline-block mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
                <path strokeLinecap="round" strokeLinejoin="round" d="M7 21a4 4 0 01-4-4V5a2 2 0 012-2h4a2 2 0 012 2v12a4 4 0 01-4 4zm0 0h12a2 2 0 002-2v-4a2 2 0 00-2-2h-2.343M11 7.343h7.071c.792 0 1.5.385 1.948 1.04A3 3 0 0122 10.87V16m-2 0h2.071M12 7.343h7.071M15 19v-4m-2 2h4" />
              </svg>
              Fill
            </button>
            <button
              onClick={() => setActiveTool('select')}
              className={`py-2 px-4 rounded-lg font-semibold transition duration-200 ${
                activeTool === 'select' ? 'bg-blue-500 text-white shadow-md' : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
              }`}
              title="Select, Move, and Resize Elements"
            >
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 inline-block mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
                <path strokeLinecap="round" strokeLinejoin="round" d="M15 15l-2 5L9 9l5-2 2-5m0 0l-5 5m2 2l-2 2m0 0l-5-5M9 9l5 5m-2-2l-2-2m0 0l-5-5" />
              </svg>
              Select
            </button>
          </div>

          {/* Emoji Selector */}
          <div className="flex flex-col items-center mt-4 md:mt-0 w-full md:w-auto">
            <span className="text-lg font-semibold mb-2">Add Emoji:</span>
            <div className="grid grid-cols-6 gap-2 w-full">
              {emojiOptions.map((emoji, index) => (
                <button
                  key={index}
                  onClick={(e) => {
                    const rect = colorCanvasRef.current.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    addEmojiToCanvas(emoji, x, y);
                  }}
                  className="p-2 bg-gray-700 rounded-md text-2xl hover:bg-gray-600 transition duration-200"
                  title={`Add ${emoji}`}
                >
                  {emoji}
                </button>
              ))}
            </div>
            <div className="flex w-full mt-2">
              <input
                type="text"
                placeholder="Paste any emoji here"
                value={emojiPasteInput}
                onChange={(e) => setEmojiPasteInput(e.target.value)}
                className="flex-grow bg-gray-700 text-white py-2 px-3 rounded-l-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm"
              />
              <button
                onClick={handlePasteEmoji}
                className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-r-md transition duration-200"
                title="Add pasted emoji"
              >
                Add
              </button>
            </div>
          </div>

          {/* Image URL Input and Button */}
          <div className="flex flex-col items-center mt-4 md:mt-0 w-full md:w-auto">
            <span className="text-lg font-semibold mb-2">Embed Image (Static):</span>
            <div className="flex w-full">
              <input
                type="text"
                placeholder="Paste image URL (e.g., .png, .jpg, .gif)"
                value={imageUrlInput}
                onChange={(e) => setImageUrlInput(e.target.value)}
                className="flex-grow bg-gray-700 text-white py-2 px-3 rounded-l-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm"
              />
              <button
                onClick={(e) => {
                  const rect = colorCanvasRef.current.getBoundingClientRect();
                  const x = e.clientX - rect.left;
                  const y = e.clientY - rect.top;
                  addImageFromUrl(imageUrlInput, x, y);
                }}
                disabled={isImageLoading}
                className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-r-md transition duration-200 flex items-center justify-center"
                title="Add image from URL"
              >
                {isImageLoading ? (
                  <svg className="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                ) : (
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
                    <path strokeLinecap="round" strokeLinejoin="round" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                  </svg>
                )}
              </button>
            </div>
          </div>

          {/* Giphy Search and Results */}
          <div className="flex flex-col items-center mt-4 md:mt-0 w-full md:w-auto">
            <span className="text-lg font-semibold mb-2">Search Giphy (Static GIF):</span>
            <div className="flex w-full">
              <input
                type="text"
                placeholder="Search for GIFs (e.g., 'cat')"
                value={giphySearchTerm}
                onChange={(e) => setGiphySearchTerm(e.target.value)}
                className="flex-grow bg-gray-700 text-white py-2 px-3 rounded-l-md focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm"
              />
              <button
                onClick={searchGiphy}
                disabled={isGiphySearching}
                className="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-r-md transition duration-200 flex items-center justify-center"
                title="Search Giphy"
              >
                {isGiphySearching ? (
                  <svg className="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                ) : (
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
                    <path strokeLinecap="round" strokeLinejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                  </svg>
                )}
              </button>
            </div>
            {giphyResults.length > 0 && (
              <div className="grid grid-cols-3 gap-2 mt-2 max-h-40 overflow-y-auto bg-gray-700 p-2 rounded-md">
                {giphyResults.map(gif => (
                  <div key={gif.id} className="relative group cursor-pointer" onClick={() => handleAddGiphy(gif)}>
                    <img src={gif.url} alt="Giphy GIF" className="w-full h-auto rounded-md object-cover group-hover:opacity-75 transition-opacity" />
                    <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 opacity-0 group-hover:opacity-100 transition-opacity rounded-md">
                      <span className="text-white text-xs font-bold">Add</span>
                    </div>
                  </div>
                ))}
              </div>
            )}
            {!GIPHY_API_KEY && (
              <p className="text-red-400 text-xs mt-2">
                Giphy API Key is missing. Giphy search will not work.
              </p>
            )}
          </div>

          {/* Delete Selected and Undo Last Stroke Buttons */}
          <div className="flex flex-wrap justify-center gap-4 mt-4 w-full">
            <button
              onClick={deleteSelectedElement}
              className="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg transform transition duration-300 ease-in-out hover:scale-105 focus:outline-none focus:ring-4 focus:ring-red-400 focus:ring-opacity-50 flex items-center space-x-2"
              title="Delete the currently selected emoji or image"
            >
              <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
                <path strokeLinecap="round" strokeLinejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
              </svg>
              <span>Delete Selected</span>
            </button>
            <button
              onClick={undoLastStroke}
              className="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transform transition duration-300 ease-in-out hover:scale-105 focus:outline-none focus:ring-4 focus:ring-gray-500 focus:ring-opacity-50 flex items-center space-x-2"
              title="Undo the last freehand drawing stroke"
            >
              <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
                <path strokeLinecap="round" strokeLinejoin="round" d="M12 19l-7-7 7-7m5 14l7-7-7-7" />
              </svg>
              <span>Undo Last Stroke</span>
            </button>
          </div>

          {/* Clear All Button */}
          <button
            onClick={clearAll}
            className="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg transform transition duration-300 ease-in-out hover:scale-105 focus:outline-none focus:ring-4 focus:ring-yellow-400 focus:ring-opacity-50 flex items-center space-x-2 mt-4 md:mt-0"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2">
              <path strokeLinecap="round" strokeLinejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
          </svg>
            <span>Clear All</span>
          </button>
        </div>
      )}

      <footer className="text-gray-400 text-sm mt-8">
        <p>&copy; 2024 Live Sketcher. All rights reserved.</p>
      </footer>
    </div>
  );
}

export default App;
